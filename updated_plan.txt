# PLAN DE TRABAJO ACTUALIZADO - NVIDIA PROJECT
# Fecha: 23 Dec 2025
# Este archivo contiene SOLO las tareas PENDIENTES del PLAN_TRABAJO.txt

## PRIORIDAD ALTA - Pr√≥ximos pasos inmediatos

### FASE 3: M√âTRICAS Y MONITOREO (2 d√≠as)

**D√≠a 5: M√©tricas en Load Balancer**
- [ ] Implementar `MetricsCollector` en Load Balancer
- [ ] Tracking: requests per image, traffic per image, latency
- [ ] Endpoint `/api/metrics` para exposici√≥n
- [ ] Endpoint `/api/mappings` para mapeo de puertos

**D√≠a 6: Integraci√≥n con UI**
- [ ] Exponer m√©tricas v√≠a API Gateway
- [ ] Dashboard en UI con gr√°ficos b√°sicos
- [ ] Auto-refresh cada 10s

### FASE 6: TESTING Y DOCUMENTACI√ìN (2 d√≠as)

**D√≠a 11-12: Testing completo**
- [ ] Unit tests para nuevos componentes
- [ ] Integration tests: Service Discovery ‚Üí Load Balancer
- [ ] E2E tests: flujo completo con Watch API
- [ ] Testing de carga y edge cases
- [ ] Documentaci√≥n actualizada

---

## PRIORIDAD MEDIA

### D√çA 7 - MEJORAS DE UI: MONITORING (4 horas)
- [ ] Mostrar health status de containers en UI
- [ ] Implementar auto-refresh de estado
- [ ] Agregar indicadores visuales
- [ ] Estad√≠sticas por imagen
- [ ] Endpoint `/api/containers/{id}/health` en Orchestrator (consulta Service Discovery/Consul)
- [ ] Polling cada 10s en frontend para actualizar estado
- [ ] Indicadores: üü¢ Running, üî¥ Stopped, üü° Unhealthy
- [ ] Contador de requests por container (si es posible, v√≠a m√©tricas del LB)

### D√çA 8 - MEJORAS DE UI: DASHBOARD Y ANALYTICS (4 horas)
- [ ] Mejorar dashboard con estad√≠sticas
- [ ] Gr√°ficos de uso de recursos
- [ ] Hist√≥rico de containers
- [ ] Export de datos
- [ ] Total de containers por estado (running/stopped)
- [ ] Containers por imagen (gr√°fico de barras)
- [ ] Hist√≥rico de creaci√≥n/eliminaci√≥n (√∫ltimos 7 d√≠as)
- [ ] Bot√≥n de export a CSV/JSON

### D√çA 9 - TESTING E2E Y REFINAMIENTO (5 horas)
- [ ] Testing completo del flujo end-to-end
- [ ] Casos edge: 0 containers, todos unhealthy, etc.
- [ ] Optimizaci√≥n de performance
- [ ] Documentaci√≥n
- [ ] Script de testing: crear 5 im√°genes, 15 containers
- [ ] Simular carga con m√∫ltiples requests simult√°neos
- [ ] Verificar Round Robin distribuye correctamente
- [ ] Medir latencia API Gateway ‚Üí Container
- [ ] Actualizar README.md con arquitectura actual

### D√çA 10 - DEPLOYMENT Y PRODUCCI√ìN (5 horas)
- [ ] Preparar para deployment
- [ ] Variables de entorno para producci√≥n
- [ ] Logging estructurado
- [ ] Monitoreo b√°sico
- [ ] Separar .env.development y .env.production
- [ ] Configurar logging level por servicio
- [ ] Agregar Prometheus metrics (opcional)
- [ ] Health checks para todos los servicios
- [ ] Script de deploy

### FASE 4: OPTIMIZACIONES (2-3 d√≠as)

**D√≠a 7-8: Routing basado en carga**
- [ ] Endpoint en Orchestrator para m√©tricas de containers (CPU, memoria)
- [ ] Modificar Load Balancer para usar Least Load algorithm
- [ ] Fallback a Round-Robin si no hay m√©tricas
- [ ] Testing de distribuci√≥n de carga

**D√≠a 9: Registry de servicios internos (opcional)**
- [ ] Service Discovery registra servicios internos del sistema (orchestrator, load-balancer, api-gateway)
- [ ] Endpoint `/api/services/system` para descubrimiento interno
- [ ] Auto-discovery de servicios
- [ ] Registrar servicios internos en Consul v√≠a Service Discovery
- [ ] Health checks para servicios internos
- [ ] Documentaci√≥n de uso

---

## PRIORIDAD BAJA - Bonus Features

### FASE 5: BONUS FEATURES (1-2 d√≠as)

**D√≠a 10: Routing geogr√°fico (bonus)**
- [ ] Integraci√≥n con geolocation API (MaxMind, ipapi.co)
- [ ] Algoritmo de selecci√≥n por distancia
- [ ] Testing con IPs simuladas
- [ ] Documentaci√≥n de feature

### D√çA 12 - ALGORITMOS DE LB AVANZADOS (5 horas)
- [ ] Implementar Least Connections algorithm
- [ ] Implementar Weighted Round Robin
- [ ] Permitir selecci√≥n de algoritmo por configuraci√≥n
- [ ] Tracking de conexiones activas por container
- [ ] Algoritmo Least Connections
- [ ] Algoritmo Weighted Round Robin (con pesos configurables)
- [ ] Configuraci√≥n de algoritmo v√≠a env var
- [ ] Testing de distribuci√≥n con diferentes algoritmos

### D√çA 13 - AUTO-SCALING (6 horas)
- [ ] Crear/eliminar containers seg√∫n carga real
- [ ] M√©tricas de carga (requests, CPU, memoria)
- [ ] Pol√≠ticas de escalado configurables
- [ ] Recolectar m√©tricas de carga por container
- [ ] Definir thresholds (min/max containers, CPU threshold, etc.)
- [ ] L√≥gica de auto-scaling (crear/eliminar containers)
- [ ] Integraci√≥n con Orchestrator para crear/eliminar containers
- [ ] Testing de escalado autom√°tico

### D√çA 14 - RATE LIMITING POR USUARIO (4 horas)
- [ ] Implementar rate limiting en API Gateway
- [ ] L√≠mites por usuario/configurables
- [ ] Headers de rate limit en respuestas
- [ ] Middleware de rate limiting en API Gateway
- [ ] Tracking de requests por usuario (en memoria o Redis)
- [ ] Headers `X-RateLimit-Limit`, `X-RateLimit-Remaining`, `X-RateLimit-Reset`
- [ ] Respuesta 429 cuando se excede l√≠mite
- [ ] Configuraci√≥n de l√≠mites por usuario

### D√çA 15 - BILLING BASADO EN USO (6 horas)
- [ ] Billing por requests, CPU, memoria (adem√°s de tiempo)
- [ ] M√©tricas de uso por container
- [ ] C√°lculo de costo basado en uso real
- [ ] Recolectar m√©tricas de uso (requests, CPU, memoria) por container
- [ ] Extender modelo de billing para incluir uso
- [ ] C√°lculo de costo basado en uso + tiempo
- [ ] Pricing rules configurables
- [ ] Endpoints para consultar billing por uso
- [ ] Agregaci√≥n por per√≠odo y reportes/export
- [ ] UI/dashboard de facturaci√≥n

### D√çA 16 - MULTI-TENANCY MEJORADO (6 horas)
- [ ] Aislar datos y recursos por tenant
- [ ] Propagar tenant context en toda la arquitectura
- [ ] M√©tricas y facturaci√≥n segmentadas por tenant
- [ ] Aislar datos por tenant (schemas separados o claves por tenant)
- [ ] Propagar tenant context en API Gateway, eventos Kafka y billing
- [ ] M√©tricas segmentadas por tenant
- [ ] Facturaci√≥n por tenant
- [ ] Testing de aislamiento

### D√çA 17 - SOPORTE PARA WEBSOCKETS (5 horas)
- [ ] Soporte WebSockets en API Gateway
- [ ] Proxy WebSocket en Load Balancer
- [ ] Upgrade de conexi√≥n HTTP a WebSocket
- [ ] Detectar upgrade requests en API Gateway
- [ ] Proxy WebSocket hacia containers
- [ ] Manejo de conexiones persistentes
- [ ] Testing de WebSocket end-to-end

### D√çA 18 - M√âTRICAS AVANZADAS CON PROMETHEUS + GRAFANA (6 horas)
- [ ] Setup Prometheus para m√©tricas
- [ ] Dashboards en Grafana
- [ ] M√©tricas avanzadas de todos los servicios
- [ ] Configurar Prometheus en docker-compose
- [ ] Exponer m√©tricas en formato Prometheus desde servicios
- [ ] Configurar Grafana con dashboards
- [ ] Dashboards para Load Balancer, Service Discovery, Orchestrator
- [ ] Alertas b√°sicas

### D√çA 19 - CI/CD PIPELINE (6 horas)
- [ ] Pipeline automatizado de integraci√≥n y deployment
- [ ] Tests autom√°ticos en cada PR
- [ ] Build y deploy autom√°tico
- [ ] Configurar GitHub Actions / GitLab CI
- [ ] Tests autom√°ticos en cada PR
- [ ] Build de im√°genes Docker autom√°tico
- [ ] Deploy autom√°tico a staging/producci√≥n
- [ ] Rollback autom√°tico en caso de fallos

### D√çA 20 - UI / PANEL PARA PROBAR SERVICIOS END-TO-END (5 horas)
- [ ] Panel en UI para probar servicios
- [ ] Requests de prueba a servicios desplegados
- [ ] Visualizaci√≥n de respuestas y m√©tricas
- [ ] Componente de testing en UI
- [ ] Formulario para hacer requests de prueba
- [ ] Visualizaci√≥n de respuestas (status, headers, body)
- [ ] M√©tricas de latencia y performance
- [ ] Historial de pruebas

### D√çA 21 - TESTING REFORZADO (8 horas)
- [ ] Suite de testing exhaustiva con edge cases
- [ ] Alta cobertura de tests
- [ ] Tests de carga y seguridad
- [ ] Unit tests con alta cobertura (>80%)
- [ ] Integration tests para todos los servicios
- [ ] E2E tests con casos edge (fallos de red, timeouts, contenedores que caen)
- [ ] Tests de carga y stress testing
- [ ] Tests de seguridad (SQL injection, XSS, etc.)
- [ ] Mocking de servicios externos (Docker, Consul, Kafka)

### D√çA 22 - KUBERNETES MIGRATION (Futuro lejano - 8 horas)
- [ ] Migrar proyecto a Kubernetes
- [ ] Crear manifests (Deployments, Services, Ingress)
- [ ] Comparar performance vs Docker Compose
- [ ] Configurar Minikube o cluster Kubernetes
- [ ] Crear manifests (Deployments, Services, Ingress)
- [ ] Adaptar servicios para Kubernetes
- [ ] Configurar ConfigMaps y Secrets
- [ ] Comparar performance vs Docker Compose actual

### D√çA 23 - GRAPHQL API (5 horas)
- [ ] Implementar GraphQL como alternativa a REST para queries m√°s flexibles
- [ ] Endpoint GraphQL en API Gateway
- [ ] Resolvers para Images, Containers, Billing
- [ ] Setup GraphQL (Strawberry o Ariadne)
- [ ] Definir schema GraphQL
- [ ] Resolvers para Images, Containers, Billing
- [ ] Integraci√≥n con servicios existentes
- [ ] Testing de queries GraphQL

### D√çA 24 - DOMINIO PROPIO Y SSL/TLS (4 horas)
- [ ] Comprar y configurar un dominio para testing/producci√≥n
- [ ] Configurar DNS
- [ ] SSL/TLS con Let's Encrypt
- [ ] Comprar dominio
- [ ] Configurar DNS (A records, CNAME)
- [ ] Configurar Let's Encrypt (certbot)
- [ ] Subdominios para servicios (api.dominio.com, ui.dominio.com)
- [ ] Renovaci√≥n autom√°tica de certificados

### D√çA 25 - GITHUB WEBHOOKS PARA DEPLOYMENT (5 horas)
- [ ] Integraci√≥n con GitHub para deployment autom√°tico
- [ ] Build autom√°tico cuando se hace push
- [ ] No almacenar c√≥digo en servidor
- [ ] Webhook endpoint que recibe push events de repositorios
- [ ] Build autom√°tico cuando se hace push a branch espec√≠fico
- [ ] Build desde GitHub directamente (no almacenar c√≥digo)
- [ ] Configuraci√≥n de repositorio por imagen/usuario
- [ ] Testing de webhooks

### D√çA 26 - KEYCLOAK PARA AUTENTICACI√ìN (6 horas)
- [ ] Reemplazar/migrar sistema de auth actual a Keycloak
- [ ] Integraci√≥n con Keycloak (OAuth2/OIDC)
- [ ] SSO (Single Sign-On)
- [ ] Setup Keycloak en docker-compose
- [ ] Integraci√≥n con Keycloak (OAuth2/OIDC)
- [ ] SSO (Single Sign-On)
- [ ] Gesti√≥n de usuarios, roles, permisos centralizada
- [ ] Migraci√≥n de usuarios existentes

---

## FASE 8: MEJORAS ADICIONALES (Opcional)

### Autenticaci√≥n en API Gateway
- [ ] Mover JWT validation al API Gateway
- [ ] Remover auth del Orchestrator
- [ ] User context propagation

### Prometheus + Grafana
- [ ] Setup Prometheus
- [ ] Grafana dashboards
- [ ] M√©tricas avanzadas

---

## RESUMEN DE TAREAS PENDIENTES POR CATEGOR√çA

### Testing y Calidad
- Testing E2E completo
- Testing de carga y edge cases
- Tests de seguridad
- Documentaci√≥n actualizada

### UI/UX
- Health status de containers en tiempo real
- Dashboard con estad√≠sticas y gr√°ficos
- Auto-refresh de estado
- Panel para probar servicios end-to-end
- Export de datos

### M√©tricas y Monitoreo
- M√©tricas en Load Balancer (requests, traffic, latency)
- Endpoints `/api/metrics` y `/api/mappings`
- Integraci√≥n con UI
- Prometheus + Grafana

### Optimizaciones
- Routing basado en carga (Least Load)
- Registry de servicios internos
- Routing geogr√°fico (bonus)
- Algoritmos LB avanzados (Least Connections, Weighted Round Robin)

### Features Avanzadas
- Auto-scaling
- Rate limiting por usuario
- Billing por uso (CPU/memoria/requests)
- Multi-tenancy mejorado
- Soporte WebSockets
- GraphQL API

### Infraestructura y Deployment
- Deployment y producci√≥n (env vars, logging, scripts)
- CI/CD pipeline
- Kubernetes migration (futuro)
- Dominio propio y SSL/TLS
- GitHub webhooks para deployment
- Keycloak para autenticaci√≥n

---

## NOTAS IMPORTANTES

### Estado actual del proyecto
- ‚úÖ Arquitectura core completada (Load Balancer, Service Discovery, API Gateway)
- ‚úÖ Circuit Breaker y Fallback implementados
- ‚úÖ Billing b√°sico operativo
- ‚úÖ Testing b√°sico implementado en varios servicios
- ‚ö†Ô∏è Pendiente: Testing E2E completo, m√©tricas avanzadas, mejoras de UI

### Prioridades recomendadas
1. **Testing E2E y Documentaci√≥n** (D√≠a 9, 11-12) - Asegurar calidad
2. **M√©tricas y Monitoreo** (D√≠a 5-6) - Visibilidad del sistema
3. **Mejoras de UI** (D√≠a 7-8) - Mejor experiencia de usuario
4. **Deployment** (D√≠a 10) - Preparar para producci√≥n
5. **Features avanzadas** (D√≠a 12-26) - Mejoras incrementales
